Exploit
=======

I was maybe a bit heavy-handed with the comment saying "look! protection
against dir traversal" and the tests trying to convince you of the same
thing - this is indeed a classic directory traversal attack, with two extra
pieces to turn it into a working exploit.

The 'issue' is that `Path.join` will throw away your existing path if the
path you're joining with is absolute. So although canonicalize-and-compare
does protect against `..` and symlinks, it doesn't help against
`Path::new("a").join("/etc/passwd")` [0]. I actually made this mistake
recently [1] so I personally think it passes as an innocent error!

Directory traversal isn't very useful by itself, especially if you
want to alter code flow (e.g. salami slice) rather than just leak data, so
I combined this with 'accidentally' overwriting keys in HashMaps without
checking for conflicts [2] - justifiable if you're assuming that all the
JSON is trusted. In terms of the execution of the
program, having currency aliases unconditionally replacing other keys in the
`CURRENCIES` hashmap lets you pick the account to receive transfer charges
for any currency you like - invisible to the end user and choosing lesser-used
aliases ('$' vs 'USD') probably lets you escape the notice of Quadrilateral.

This brings me to the final (and the most entertaining to me) part - so far we
can pick a path, and if there's valid data in the path then we can get it
loaded into the application and make it give us money. But where can we get
data from? Hardcoding (e.g. some example files in a 'tests' directory) would
work, but was too static and easy to spot - I wanted something dynamic,
remotely controllable and isn't as obvious as "please keep using this crate I
own so I can create files on disk". If you've not already figured it all out,
you might want to stop here and have a think about how the crucial final step
might work! (note that `script.sh` just makes requests via curl, there's no
file creation in it)

----

It turns out there's one data source that we can rely on being on any machine
used to build Rust projects - the crates.io index! I crafted the `Currency`
and `CurrencyFeatures` to match up to the crates.io JSON, e.g.

 - the (oddly named) `features` field
 - using `Vec<String>` for `transfer_charge_accounts` and making up a justification
   to do with account rotation (rather than a simpler single u64) because that's what
   [crates.io emits](https://github.com/rust-lang/crates.io/blob/7f731d4/src/git.rs#L21)

This was combined with some misdirection with `Optional<_>` to distract from
the suspicious crates.io-like field naming, relying on the helpful behaviour of
`serde_json` to ignore fields it's not expecting. Bors
[faithfully committed](https://github.com/rust-lang/crates.io-index/commit/7478a2083899402e1b2ed44287b194c06ada748b)
my JSON, and it's primed for slicing salamis [3]. If I wanted to start skimming
off other currencies, I just need to publish another crate and wait for
Quadrilateral to inevitably update their crates.io index.

Summary
-------

The good:

 - Works on 1.15.0 stable upwards (and downwards, if I replace serde derive
   with codegen)
 - (Mostly) explicable as innocent error in programming (there's even a test
   of the buggy area to show willing!)
 - Clippy has nothing to say
 - Fully dynamic and remotely controllable exploit (no hardcoded accounts)
 - Uses the crates.io index as a vulnerability delivery method!

The meh:

 - I could demonstrate variations of this bug in any language...I
   guess the lesson is that Rust doesn't (can't) help with bad path handling
   and basically every language has made the decision that silent replacement
   in HashMaps is the ergonomic route forward
 - Requires a crates.io index on the machine where this runs. Possibly not as
   unlikely as you might think, especially given there's a Dockerfile the
   company can use with zero effort

[0] This behaviour is the same as in Python

[1] I've read the docs for both Python and Rust path joining many times, but
unfortunately I'd forgotten them until I stumbled across the behaviour
recently when I *did* want to join absolute paths as a suffix. It ended up
being surprisingly tricky
[to do this](https://github.com/aidanhs/machroot/commit/772507eda42c2fda#diff-639fbc4ef05b315af92b4d836c31b023R87),
but perhaps I missed something.

[2] Whenever I personally use hashmaps, throwing away old entries is so rarely
what I want to do that I pretty much always wrap inserts with assertions, like
https://github.com/aidanhs/ayzim/blob/master/src/optimizer.rs#L1332-L1333 and
many others in that file.

[3] To be explicit, I don't consider this coming anywhere near
violating the "Do not submit patches upstream, or otherwise inject
malicious code into any dependency in the wild" rule - this is metadata that's
only possibly useful for this toy vulnerability contest.
