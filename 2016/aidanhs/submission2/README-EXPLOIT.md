Exploit
=======

In an interesting twist, this exploit may be more obvious to users who aren't
so familiar with Rust and/or have experience in other languages - it actually
uses data races to do its thing.

"But wait!" I hear you cry, "there are no data races in safe Rust, and I see
no unsafe in your code!". This is why I say the issue may be more discoverable
for people who perhaps don't take Rust promises for granted :)

The problem is that no data races is not *quite* true thanks to a known bug [0]
that's had remarkably little attention, likely partly because it's not
immediately obvious what damage you can do and partly because fixing it would
break quite a lot. After thinking about it for a while, I still couldn't
come up with many places where it would do terrible things - you can do a
"I `mem::replace`d a bit of data and I then accessed a field on it which gave
me an unexpected value because the borrow checker didn't warn me", but there
are variations of this 'problem' in safe code as well [1], and it just gives you
an unexpected but consistent result. I wanted something better than that, to
make sure the slicing was more subtle and can be activated for just me.

In the end, I concluded that (as far as I could see, which may not be very far!)
the issue only gets interesting if you have a) noalias data being generated
*within* functions [2] or b) data races. Since a does not exist in Rust right now
it had to be b. So, what kind of mutation could we justify? Remember, all that
can be done is change where the reference points to, so memory safety bugs are
not easy. In the end I decided that a `mem::replace` of a struct with some
sentinel value would be easiest (and justifiable since the code would be
significantly uglier if all the `UserAccount`s in the DB were in `Option`s).
However, I needed some way of getting the `&mut` reference into the thread and
only doing the `mem::replace` in there (otherwise it's not racing) - this is
where the `crossbeam` scoped threads api comes in (totally safe...assuming no
bugs in `rustc`), permitting the `&mut` reference to be sent to another thread.

So there's a data race in place, all that's left is to find a way to slow down
the timings in a way that lets me perform the exploit in a repeatable way. I
happen to know that fraud checks can want to talk to external services, so
the fake delay inserted is not unrealistic for an real implementation. Rate
limiting was then added to have some timing I can remotely control, useful for
reacting to changes in response time of the fraud service.

The whole overdrafts thing is just to justify using `i64` just so the exploit
works in debug mode. Note that it'd also work fine in release mode with `u64` due
to defined wrapping behaviour.

Summary
-------

The good:

 - Works on 1.15.0 stable upwards (and probably downwards)
 - No `unsafe`, mostly defensible design decisions
 - Clippy has nothing to say
 - Fully dynamic and remotely controllable exploit (no hardcoded accounts)
 - Scratches off bullet point 4 of rust-lang.org! ("threads without data races")

The meh:

 - Relies on a known soundness bug (though severity is perhaps underestimated
   at the moment)
 - Relies rather heavily on not questioning the `transfer_charge: -1.0` in the
   fake currency. I think it may be possible to come up with something with the
   infinities and NaN, but it'd look more suspicious.

[0] https://github.com/rust-lang/rust/issues/38899 - it's also marked `I-unsound`
so has likely been at least considered for submission by other underhanded
rustaceans.

[1] Trivial example:
```
let mut x = ...;
foo(mem::replace(&mut x, ...));
bar(x.a); // not the x you were looking for
```
As you can see, this isn't a great basis for an exploit.

[2] A brief background: alias annotations were previously generated on function
arguments, but were disabled because they were buggy. You can follow the chain
of issues downwards from https://github.com/rust-lang/rust/issues/31681 if
you're interested. However, in addition to argument alias analysis, there's
scoped alias analysis data (https://github.com/rust-lang/rust/issues/16515)
which is likely to bring all sorts of new miscompilation opportunities with it.
This latter set of metadata is what I'm referring to, though I didn't fully
think through whether the exploit would be possible with it - just suspicions.
